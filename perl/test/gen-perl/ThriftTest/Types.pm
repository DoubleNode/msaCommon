#
# Autogenerated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

package ThriftTest::Numberz;
use constant ONE => 1;
use constant TWO => 2;
use constant THREE => 3;
use constant FIVE => 5;
use constant SIX => 6;
use constant EIGHT => 8;
package ThriftTest::Bonk;
use base qw(Class::Accessor);
ThriftTest::Bonk->mk_accessors( qw( message type ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{message} = undef;
  $self->{type} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{message}) {
      $self->{message} = $vals->{message};
    }
    if (defined $vals->{type}) {
      $self->{type} = $vals->{type};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Bonk';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{message});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Bonk');
  if (defined $self->{message}) {
    $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
    $xfer += $output->writeString($self->{message});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{type}) {
    $xfer += $output->writeFieldBegin('type', TType::I32, 2);
    $xfer += $output->writeI32($self->{type});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::Bools;
use base qw(Class::Accessor);
ThriftTest::Bools->mk_accessors( qw( im_true im_false ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{im_true} = undef;
  $self->{im_false} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{im_true}) {
      $self->{im_true} = $vals->{im_true};
    }
    if (defined $vals->{im_false}) {
      $self->{im_false} = $vals->{im_false};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Bools';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{im_true});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{im_false});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Bools');
  if (defined $self->{im_true}) {
    $xfer += $output->writeFieldBegin('im_true', TType::BOOL, 1);
    $xfer += $output->writeBool($self->{im_true});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{im_false}) {
    $xfer += $output->writeFieldBegin('im_false', TType::BOOL, 2);
    $xfer += $output->writeBool($self->{im_false});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::Xtruct;
use base qw(Class::Accessor);
ThriftTest::Xtruct->mk_accessors( qw( string_thing byte_thing i32_thing i64_thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{string_thing} = undef;
  $self->{byte_thing} = undef;
  $self->{i32_thing} = undef;
  $self->{i64_thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{string_thing}) {
      $self->{string_thing} = $vals->{string_thing};
    }
    if (defined $vals->{byte_thing}) {
      $self->{byte_thing} = $vals->{byte_thing};
    }
    if (defined $vals->{i32_thing}) {
      $self->{i32_thing} = $vals->{i32_thing};
    }
    if (defined $vals->{i64_thing}) {
      $self->{i64_thing} = $vals->{i64_thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Xtruct';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{string_thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{byte_thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{i32_thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^11$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{i64_thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Xtruct');
  if (defined $self->{string_thing}) {
    $xfer += $output->writeFieldBegin('string_thing', TType::STRING, 1);
    $xfer += $output->writeString($self->{string_thing});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{byte_thing}) {
    $xfer += $output->writeFieldBegin('byte_thing', TType::BYTE, 4);
    $xfer += $output->writeByte($self->{byte_thing});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{i32_thing}) {
    $xfer += $output->writeFieldBegin('i32_thing', TType::I32, 9);
    $xfer += $output->writeI32($self->{i32_thing});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{i64_thing}) {
    $xfer += $output->writeFieldBegin('i64_thing', TType::I64, 11);
    $xfer += $output->writeI64($self->{i64_thing});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::Xtruct2;
use base qw(Class::Accessor);
ThriftTest::Xtruct2->mk_accessors( qw( byte_thing struct_thing i32_thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{byte_thing} = undef;
  $self->{struct_thing} = undef;
  $self->{i32_thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{byte_thing}) {
      $self->{byte_thing} = $vals->{byte_thing};
    }
    if (defined $vals->{struct_thing}) {
      $self->{struct_thing} = $vals->{struct_thing};
    }
    if (defined $vals->{i32_thing}) {
      $self->{i32_thing} = $vals->{i32_thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Xtruct2';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{byte_thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{struct_thing} = new ThriftTest::Xtruct();
        $xfer += $self->{struct_thing}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{i32_thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Xtruct2');
  if (defined $self->{byte_thing}) {
    $xfer += $output->writeFieldBegin('byte_thing', TType::BYTE, 1);
    $xfer += $output->writeByte($self->{byte_thing});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{struct_thing}) {
    $xfer += $output->writeFieldBegin('struct_thing', TType::STRUCT, 2);
    $xfer += $self->{struct_thing}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{i32_thing}) {
    $xfer += $output->writeFieldBegin('i32_thing', TType::I32, 3);
    $xfer += $output->writeI32($self->{i32_thing});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::Xtruct3;
use base qw(Class::Accessor);
ThriftTest::Xtruct3->mk_accessors( qw( string_thing changed i32_thing i64_thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{string_thing} = undef;
  $self->{changed} = undef;
  $self->{i32_thing} = undef;
  $self->{i64_thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{string_thing}) {
      $self->{string_thing} = $vals->{string_thing};
    }
    if (defined $vals->{changed}) {
      $self->{changed} = $vals->{changed};
    }
    if (defined $vals->{i32_thing}) {
      $self->{i32_thing} = $vals->{i32_thing};
    }
    if (defined $vals->{i64_thing}) {
      $self->{i64_thing} = $vals->{i64_thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Xtruct3';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{string_thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{changed});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{i32_thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^11$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{i64_thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Xtruct3');
  if (defined $self->{string_thing}) {
    $xfer += $output->writeFieldBegin('string_thing', TType::STRING, 1);
    $xfer += $output->writeString($self->{string_thing});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{changed}) {
    $xfer += $output->writeFieldBegin('changed', TType::I32, 4);
    $xfer += $output->writeI32($self->{changed});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{i32_thing}) {
    $xfer += $output->writeFieldBegin('i32_thing', TType::I32, 9);
    $xfer += $output->writeI32($self->{i32_thing});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{i64_thing}) {
    $xfer += $output->writeFieldBegin('i64_thing', TType::I64, 11);
    $xfer += $output->writeI64($self->{i64_thing});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::Insanity;
use base qw(Class::Accessor);
ThriftTest::Insanity->mk_accessors( qw( userMap xtructs ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{userMap} = undef;
  $self->{xtructs} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{userMap}) {
      $self->{userMap} = $vals->{userMap};
    }
    if (defined $vals->{xtructs}) {
      $self->{xtructs} = $vals->{xtructs};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Insanity';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size0 = 0;
          $self->{userMap} = {};
          my $_ktype1 = 0;
          my $_vtype2 = 0;
          $xfer += $input->readMapBegin(\$_ktype1, \$_vtype2, \$_size0);
          for (my $_i4 = 0; $_i4 < $_size0; ++$_i4)
          {
            my $key5 = 0;
            my $val6 = 0;
            $xfer += $input->readI32(\$key5);
            $xfer += $input->readI64(\$val6);
            $self->{userMap}->{$key5} = $val6;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size7 = 0;
          $self->{xtructs} = [];
          my $_etype10 = 0;
          $xfer += $input->readListBegin(\$_etype10, \$_size7);
          for (my $_i11 = 0; $_i11 < $_size7; ++$_i11)
          {
            my $elem12 = undef;
            $elem12 = new ThriftTest::Xtruct();
            $xfer += $elem12->read($input);
            push(@{$self->{xtructs}},$elem12);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Insanity');
  if (defined $self->{userMap}) {
    $xfer += $output->writeFieldBegin('userMap', TType::MAP, 1);
    {
      $xfer += $output->writeMapBegin(TType::I32, TType::I64, scalar(keys %{$self->{userMap}}));
      {
        while( my ($kiter13,$viter14) = each %{$self->{userMap}}) 
        {
          $xfer += $output->writeI32($kiter13);
          $xfer += $output->writeI64($viter14);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{xtructs}) {
    $xfer += $output->writeFieldBegin('xtructs', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{xtructs}}));
      {
        foreach my $iter15 (@{$self->{xtructs}}) 
        {
          $xfer += ${iter15}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::CrazyNesting;
use base qw(Class::Accessor);
ThriftTest::CrazyNesting->mk_accessors( qw( string_field set_field list_field binary_field ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{string_field} = undef;
  $self->{set_field} = undef;
  $self->{list_field} = undef;
  $self->{binary_field} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{string_field}) {
      $self->{string_field} = $vals->{string_field};
    }
    if (defined $vals->{set_field}) {
      $self->{set_field} = $vals->{set_field};
    }
    if (defined $vals->{list_field}) {
      $self->{list_field} = $vals->{list_field};
    }
    if (defined $vals->{binary_field}) {
      $self->{binary_field} = $vals->{binary_field};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'CrazyNesting';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{string_field});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::SET) {
        {
          my $_size16 = 0;
          $self->{set_field} = {};
          my $_etype19 = 0;
          $xfer += $input->readSetBegin(\$_etype19, \$_size16);
          for (my $_i20 = 0; $_i20 < $_size16; ++$_i20)
          {
            my $elem21 = undef;
            $elem21 = new ThriftTest::Insanity();
            $xfer += $elem21->read($input);
            $self->{set_field}->{$elem21} = 1;
          }
          $xfer += $input->readSetEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size22 = 0;
          $self->{list_field} = [];
          my $_etype25 = 0;
          $xfer += $input->readListBegin(\$_etype25, \$_size22);
          for (my $_i26 = 0; $_i26 < $_size22; ++$_i26)
          {
            my $elem27 = undef;
            {
              my $_size28 = 0;
              $elem27 = {};
              my $_ktype29 = 0;
              my $_vtype30 = 0;
              $xfer += $input->readMapBegin(\$_ktype29, \$_vtype30, \$_size28);
              for (my $_i32 = 0; $_i32 < $_size28; ++$_i32)
              {
                my $key33 = [];
                my $val34 = [];
                {
                  my $_size35 = 0;
                  $key33 = {};
                  my $_etype38 = 0;
                  $xfer += $input->readSetBegin(\$_etype38, \$_size35);
                  for (my $_i39 = 0; $_i39 < $_size35; ++$_i39)
                  {
                    my $elem40 = undef;
                    $xfer += $input->readI32(\$elem40);
                    $key33->{$elem40} = 1;
                  }
                  $xfer += $input->readSetEnd();
                }
                {
                  my $_size41 = 0;
                  $val34 = {};
                  my $_ktype42 = 0;
                  my $_vtype43 = 0;
                  $xfer += $input->readMapBegin(\$_ktype42, \$_vtype43, \$_size41);
                  for (my $_i45 = 0; $_i45 < $_size41; ++$_i45)
                  {
                    my $key46 = 0;
                    my $val47 = [];
                    $xfer += $input->readI32(\$key46);
                    {
                      my $_size48 = 0;
                      $val47 = {};
                      my $_etype51 = 0;
                      $xfer += $input->readSetBegin(\$_etype51, \$_size48);
                      for (my $_i52 = 0; $_i52 < $_size48; ++$_i52)
                      {
                        my $elem53 = undef;
                        {
                          my $_size54 = 0;
                          $elem53 = [];
                          my $_etype57 = 0;
                          $xfer += $input->readListBegin(\$_etype57, \$_size54);
                          for (my $_i58 = 0; $_i58 < $_size54; ++$_i58)
                          {
                            my $elem59 = undef;
                            {
                              my $_size60 = 0;
                              $elem59 = {};
                              my $_ktype61 = 0;
                              my $_vtype62 = 0;
                              $xfer += $input->readMapBegin(\$_ktype61, \$_vtype62, \$_size60);
                              for (my $_i64 = 0; $_i64 < $_size60; ++$_i64)
                              {
                                my $key65 = new ThriftTest::Insanity();
                                my $val66 = '';
                                $key65 = new ThriftTest::Insanity();
                                $xfer += $key65->read($input);
                                $xfer += $input->readString(\$val66);
                                $elem59->{$key65} = $val66;
                              }
                              $xfer += $input->readMapEnd();
                            }
                            push(@{$elem53},$elem59);
                          }
                          $xfer += $input->readListEnd();
                        }
                        $val47->{$elem53} = 1;
                      }
                      $xfer += $input->readSetEnd();
                    }
                    $val34->{$key46} = $val47;
                  }
                  $xfer += $input->readMapEnd();
                }
                $elem27->{$key33} = $val34;
              }
              $xfer += $input->readMapEnd();
            }
            push(@{$self->{list_field}},$elem27);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{binary_field});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('CrazyNesting');
  if (defined $self->{string_field}) {
    $xfer += $output->writeFieldBegin('string_field', TType::STRING, 1);
    $xfer += $output->writeString($self->{string_field});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{set_field}) {
    $xfer += $output->writeFieldBegin('set_field', TType::SET, 2);
    {
      $xfer += $output->writeSetBegin(TType::STRUCT, scalar(@{$self->{set_field}}));
      {
        foreach my $iter67 (@{$self->{set_field}})
        {
          $xfer += ${iter67}->write($output);
        }
      }
      $xfer += $output->writeSetEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{list_field}) {
    $xfer += $output->writeFieldBegin('list_field', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::MAP, scalar(@{$self->{list_field}}));
      {
        foreach my $iter68 (@{$self->{list_field}}) 
        {
          {
            $xfer += $output->writeMapBegin(TType::SET, TType::MAP, scalar(keys %{${iter68}}));
            {
              while( my ($kiter69,$viter70) = each %{${iter68}}) 
              {
                {
                  $xfer += $output->writeSetBegin(TType::I32, scalar(@{${kiter69}}));
                  {
                    foreach my $iter71 (@{${kiter69}})
                    {
                      $xfer += $output->writeI32($iter71);
                    }
                  }
                  $xfer += $output->writeSetEnd();
                }
                {
                  $xfer += $output->writeMapBegin(TType::I32, TType::SET, scalar(keys %{${viter70}}));
                  {
                    while( my ($kiter72,$viter73) = each %{${viter70}}) 
                    {
                      $xfer += $output->writeI32($kiter72);
                      {
                        $xfer += $output->writeSetBegin(TType::LIST, scalar(@{${viter73}}));
                        {
                          foreach my $iter74 (@{${viter73}})
                          {
                            {
                              $xfer += $output->writeListBegin(TType::MAP, scalar(@{${iter74}}));
                              {
                                foreach my $iter75 (@{${iter74}}) 
                                {
                                  {
                                    $xfer += $output->writeMapBegin(TType::STRUCT, TType::STRING, scalar(keys %{${iter75}}));
                                    {
                                      while( my ($kiter76,$viter77) = each %{${iter75}}) 
                                      {
                                        $xfer += ${kiter76}->write($output);
                                        $xfer += $output->writeString($viter77);
                                      }
                                    }
                                    $xfer += $output->writeMapEnd();
                                  }
                                }
                              }
                              $xfer += $output->writeListEnd();
                            }
                          }
                        }
                        $xfer += $output->writeSetEnd();
                      }
                    }
                  }
                  $xfer += $output->writeMapEnd();
                }
              }
            }
            $xfer += $output->writeMapEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{binary_field}) {
    $xfer += $output->writeFieldBegin('binary_field', TType::STRING, 4);
    $xfer += $output->writeString($self->{binary_field});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::Xception;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
ThriftTest::Xception->mk_accessors( qw( errorCode message ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{errorCode} = undef;
  $self->{message} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{errorCode}) {
      $self->{errorCode} = $vals->{errorCode};
    }
    if (defined $vals->{message}) {
      $self->{message} = $vals->{message};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Xception';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{errorCode});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{message});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Xception');
  if (defined $self->{errorCode}) {
    $xfer += $output->writeFieldBegin('errorCode', TType::I32, 1);
    $xfer += $output->writeI32($self->{errorCode});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{message}) {
    $xfer += $output->writeFieldBegin('message', TType::STRING, 2);
    $xfer += $output->writeString($self->{message});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::Xception2;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
ThriftTest::Xception2->mk_accessors( qw( errorCode struct_thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{errorCode} = undef;
  $self->{struct_thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{errorCode}) {
      $self->{errorCode} = $vals->{errorCode};
    }
    if (defined $vals->{struct_thing}) {
      $self->{struct_thing} = $vals->{struct_thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Xception2';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{errorCode});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{struct_thing} = new ThriftTest::Xtruct();
        $xfer += $self->{struct_thing}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Xception2');
  if (defined $self->{errorCode}) {
    $xfer += $output->writeFieldBegin('errorCode', TType::I32, 1);
    $xfer += $output->writeI32($self->{errorCode});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{struct_thing}) {
    $xfer += $output->writeFieldBegin('struct_thing', TType::STRUCT, 2);
    $xfer += $self->{struct_thing}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::EmptyStruct;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'EmptyStruct';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('EmptyStruct');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::OneField;
use base qw(Class::Accessor);
ThriftTest::OneField->mk_accessors( qw( field ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{field} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{field}) {
      $self->{field} = $vals->{field};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'OneField';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{field} = new ThriftTest::EmptyStruct();
        $xfer += $self->{field}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('OneField');
  if (defined $self->{field}) {
    $xfer += $output->writeFieldBegin('field', TType::STRUCT, 1);
    $xfer += $self->{field}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::VersioningTestV1;
use base qw(Class::Accessor);
ThriftTest::VersioningTestV1->mk_accessors( qw( begin_in_both old_string end_in_both ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{begin_in_both} = undef;
  $self->{old_string} = undef;
  $self->{end_in_both} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{begin_in_both}) {
      $self->{begin_in_both} = $vals->{begin_in_both};
    }
    if (defined $vals->{old_string}) {
      $self->{old_string} = $vals->{old_string};
    }
    if (defined $vals->{end_in_both}) {
      $self->{end_in_both} = $vals->{end_in_both};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'VersioningTestV1';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{begin_in_both});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{old_string});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^12$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{end_in_both});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('VersioningTestV1');
  if (defined $self->{begin_in_both}) {
    $xfer += $output->writeFieldBegin('begin_in_both', TType::I32, 1);
    $xfer += $output->writeI32($self->{begin_in_both});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{old_string}) {
    $xfer += $output->writeFieldBegin('old_string', TType::STRING, 3);
    $xfer += $output->writeString($self->{old_string});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{end_in_both}) {
    $xfer += $output->writeFieldBegin('end_in_both', TType::I32, 12);
    $xfer += $output->writeI32($self->{end_in_both});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::VersioningTestV2;
use base qw(Class::Accessor);
ThriftTest::VersioningTestV2->mk_accessors( qw( begin_in_both newint newbyte newshort newlong newdouble newstruct newlist newset newmap newstring end_in_both ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{begin_in_both} = undef;
  $self->{newint} = undef;
  $self->{newbyte} = undef;
  $self->{newshort} = undef;
  $self->{newlong} = undef;
  $self->{newdouble} = undef;
  $self->{newstruct} = undef;
  $self->{newlist} = undef;
  $self->{newset} = undef;
  $self->{newmap} = undef;
  $self->{newstring} = undef;
  $self->{end_in_both} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{begin_in_both}) {
      $self->{begin_in_both} = $vals->{begin_in_both};
    }
    if (defined $vals->{newint}) {
      $self->{newint} = $vals->{newint};
    }
    if (defined $vals->{newbyte}) {
      $self->{newbyte} = $vals->{newbyte};
    }
    if (defined $vals->{newshort}) {
      $self->{newshort} = $vals->{newshort};
    }
    if (defined $vals->{newlong}) {
      $self->{newlong} = $vals->{newlong};
    }
    if (defined $vals->{newdouble}) {
      $self->{newdouble} = $vals->{newdouble};
    }
    if (defined $vals->{newstruct}) {
      $self->{newstruct} = $vals->{newstruct};
    }
    if (defined $vals->{newlist}) {
      $self->{newlist} = $vals->{newlist};
    }
    if (defined $vals->{newset}) {
      $self->{newset} = $vals->{newset};
    }
    if (defined $vals->{newmap}) {
      $self->{newmap} = $vals->{newmap};
    }
    if (defined $vals->{newstring}) {
      $self->{newstring} = $vals->{newstring};
    }
    if (defined $vals->{end_in_both}) {
      $self->{end_in_both} = $vals->{end_in_both};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'VersioningTestV2';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{begin_in_both});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{newint});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{newbyte});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{newshort});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{newlong});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{newdouble});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{newstruct} = new ThriftTest::Bonk();
        $xfer += $self->{newstruct}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size78 = 0;
          $self->{newlist} = [];
          my $_etype81 = 0;
          $xfer += $input->readListBegin(\$_etype81, \$_size78);
          for (my $_i82 = 0; $_i82 < $_size78; ++$_i82)
          {
            my $elem83 = undef;
            $xfer += $input->readI32(\$elem83);
            push(@{$self->{newlist}},$elem83);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::SET) {
        {
          my $_size84 = 0;
          $self->{newset} = {};
          my $_etype87 = 0;
          $xfer += $input->readSetBegin(\$_etype87, \$_size84);
          for (my $_i88 = 0; $_i88 < $_size84; ++$_i88)
          {
            my $elem89 = undef;
            $xfer += $input->readI32(\$elem89);
            $self->{newset}->{$elem89} = 1;
          }
          $xfer += $input->readSetEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size90 = 0;
          $self->{newmap} = {};
          my $_ktype91 = 0;
          my $_vtype92 = 0;
          $xfer += $input->readMapBegin(\$_ktype91, \$_vtype92, \$_size90);
          for (my $_i94 = 0; $_i94 < $_size90; ++$_i94)
          {
            my $key95 = 0;
            my $val96 = 0;
            $xfer += $input->readI32(\$key95);
            $xfer += $input->readI32(\$val96);
            $self->{newmap}->{$key95} = $val96;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^11$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{newstring});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^12$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{end_in_both});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('VersioningTestV2');
  if (defined $self->{begin_in_both}) {
    $xfer += $output->writeFieldBegin('begin_in_both', TType::I32, 1);
    $xfer += $output->writeI32($self->{begin_in_both});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{newint}) {
    $xfer += $output->writeFieldBegin('newint', TType::I32, 2);
    $xfer += $output->writeI32($self->{newint});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{newbyte}) {
    $xfer += $output->writeFieldBegin('newbyte', TType::BYTE, 3);
    $xfer += $output->writeByte($self->{newbyte});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{newshort}) {
    $xfer += $output->writeFieldBegin('newshort', TType::I16, 4);
    $xfer += $output->writeI16($self->{newshort});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{newlong}) {
    $xfer += $output->writeFieldBegin('newlong', TType::I64, 5);
    $xfer += $output->writeI64($self->{newlong});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{newdouble}) {
    $xfer += $output->writeFieldBegin('newdouble', TType::DOUBLE, 6);
    $xfer += $output->writeDouble($self->{newdouble});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{newstruct}) {
    $xfer += $output->writeFieldBegin('newstruct', TType::STRUCT, 7);
    $xfer += $self->{newstruct}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{newlist}) {
    $xfer += $output->writeFieldBegin('newlist', TType::LIST, 8);
    {
      $xfer += $output->writeListBegin(TType::I32, scalar(@{$self->{newlist}}));
      {
        foreach my $iter97 (@{$self->{newlist}}) 
        {
          $xfer += $output->writeI32($iter97);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{newset}) {
    $xfer += $output->writeFieldBegin('newset', TType::SET, 9);
    {
      $xfer += $output->writeSetBegin(TType::I32, scalar(@{$self->{newset}}));
      {
        foreach my $iter98 (@{$self->{newset}})
        {
          $xfer += $output->writeI32($iter98);
        }
      }
      $xfer += $output->writeSetEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{newmap}) {
    $xfer += $output->writeFieldBegin('newmap', TType::MAP, 10);
    {
      $xfer += $output->writeMapBegin(TType::I32, TType::I32, scalar(keys %{$self->{newmap}}));
      {
        while( my ($kiter99,$viter100) = each %{$self->{newmap}}) 
        {
          $xfer += $output->writeI32($kiter99);
          $xfer += $output->writeI32($viter100);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{newstring}) {
    $xfer += $output->writeFieldBegin('newstring', TType::STRING, 11);
    $xfer += $output->writeString($self->{newstring});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{end_in_both}) {
    $xfer += $output->writeFieldBegin('end_in_both', TType::I32, 12);
    $xfer += $output->writeI32($self->{end_in_both});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ListTypeVersioningV1;
use base qw(Class::Accessor);
ThriftTest::ListTypeVersioningV1->mk_accessors( qw( myints hello ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{myints} = undef;
  $self->{hello} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{myints}) {
      $self->{myints} = $vals->{myints};
    }
    if (defined $vals->{hello}) {
      $self->{hello} = $vals->{hello};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ListTypeVersioningV1';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size101 = 0;
          $self->{myints} = [];
          my $_etype104 = 0;
          $xfer += $input->readListBegin(\$_etype104, \$_size101);
          for (my $_i105 = 0; $_i105 < $_size101; ++$_i105)
          {
            my $elem106 = undef;
            $xfer += $input->readI32(\$elem106);
            push(@{$self->{myints}},$elem106);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{hello});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ListTypeVersioningV1');
  if (defined $self->{myints}) {
    $xfer += $output->writeFieldBegin('myints', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::I32, scalar(@{$self->{myints}}));
      {
        foreach my $iter107 (@{$self->{myints}}) 
        {
          $xfer += $output->writeI32($iter107);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{hello}) {
    $xfer += $output->writeFieldBegin('hello', TType::STRING, 2);
    $xfer += $output->writeString($self->{hello});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ListTypeVersioningV2;
use base qw(Class::Accessor);
ThriftTest::ListTypeVersioningV2->mk_accessors( qw( strings hello ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{strings} = undef;
  $self->{hello} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{strings}) {
      $self->{strings} = $vals->{strings};
    }
    if (defined $vals->{hello}) {
      $self->{hello} = $vals->{hello};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ListTypeVersioningV2';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size108 = 0;
          $self->{strings} = [];
          my $_etype111 = 0;
          $xfer += $input->readListBegin(\$_etype111, \$_size108);
          for (my $_i112 = 0; $_i112 < $_size108; ++$_i112)
          {
            my $elem113 = undef;
            $xfer += $input->readString(\$elem113);
            push(@{$self->{strings}},$elem113);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{hello});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ListTypeVersioningV2');
  if (defined $self->{strings}) {
    $xfer += $output->writeFieldBegin('strings', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{strings}}));
      {
        foreach my $iter114 (@{$self->{strings}}) 
        {
          $xfer += $output->writeString($iter114);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{hello}) {
    $xfer += $output->writeFieldBegin('hello', TType::STRING, 2);
    $xfer += $output->writeString($self->{hello});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::GuessProtocolStruct;
use base qw(Class::Accessor);
ThriftTest::GuessProtocolStruct->mk_accessors( qw( map_field ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{map_field} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{map_field}) {
      $self->{map_field} = $vals->{map_field};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'GuessProtocolStruct';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^7$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size115 = 0;
          $self->{map_field} = {};
          my $_ktype116 = 0;
          my $_vtype117 = 0;
          $xfer += $input->readMapBegin(\$_ktype116, \$_vtype117, \$_size115);
          for (my $_i119 = 0; $_i119 < $_size115; ++$_i119)
          {
            my $key120 = '';
            my $val121 = '';
            $xfer += $input->readString(\$key120);
            $xfer += $input->readString(\$val121);
            $self->{map_field}->{$key120} = $val121;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('GuessProtocolStruct');
  if (defined $self->{map_field}) {
    $xfer += $output->writeFieldBegin('map_field', TType::MAP, 7);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{map_field}}));
      {
        while( my ($kiter122,$viter123) = each %{$self->{map_field}}) 
        {
          $xfer += $output->writeString($kiter122);
          $xfer += $output->writeString($viter123);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::LargeDeltas;
use base qw(Class::Accessor);
ThriftTest::LargeDeltas->mk_accessors( qw( b1 b10 b100 check_true b1000 check_false vertwo2000 a_set2500 vertwo3000 big_numbers ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{b1} = undef;
  $self->{b10} = undef;
  $self->{b100} = undef;
  $self->{check_true} = undef;
  $self->{b1000} = undef;
  $self->{check_false} = undef;
  $self->{vertwo2000} = undef;
  $self->{a_set2500} = undef;
  $self->{vertwo3000} = undef;
  $self->{big_numbers} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{b1}) {
      $self->{b1} = $vals->{b1};
    }
    if (defined $vals->{b10}) {
      $self->{b10} = $vals->{b10};
    }
    if (defined $vals->{b100}) {
      $self->{b100} = $vals->{b100};
    }
    if (defined $vals->{check_true}) {
      $self->{check_true} = $vals->{check_true};
    }
    if (defined $vals->{b1000}) {
      $self->{b1000} = $vals->{b1000};
    }
    if (defined $vals->{check_false}) {
      $self->{check_false} = $vals->{check_false};
    }
    if (defined $vals->{vertwo2000}) {
      $self->{vertwo2000} = $vals->{vertwo2000};
    }
    if (defined $vals->{a_set2500}) {
      $self->{a_set2500} = $vals->{a_set2500};
    }
    if (defined $vals->{vertwo3000}) {
      $self->{vertwo3000} = $vals->{vertwo3000};
    }
    if (defined $vals->{big_numbers}) {
      $self->{big_numbers} = $vals->{big_numbers};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'LargeDeltas';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{b1} = new ThriftTest::Bools();
        $xfer += $self->{b1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{b10} = new ThriftTest::Bools();
        $xfer += $self->{b10}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^100$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{b100} = new ThriftTest::Bools();
        $xfer += $self->{b100}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^500$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{check_true});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1000$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{b1000} = new ThriftTest::Bools();
        $xfer += $self->{b1000}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1500$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{check_false});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2000$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{vertwo2000} = new ThriftTest::VersioningTestV2();
        $xfer += $self->{vertwo2000}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2500$/ && do{      if ($ftype == TType::SET) {
        {
          my $_size124 = 0;
          $self->{a_set2500} = {};
          my $_etype127 = 0;
          $xfer += $input->readSetBegin(\$_etype127, \$_size124);
          for (my $_i128 = 0; $_i128 < $_size124; ++$_i128)
          {
            my $elem129 = undef;
            $xfer += $input->readString(\$elem129);
            $self->{a_set2500}->{$elem129} = 1;
          }
          $xfer += $input->readSetEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3000$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{vertwo3000} = new ThriftTest::VersioningTestV2();
        $xfer += $self->{vertwo3000}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4000$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size130 = 0;
          $self->{big_numbers} = [];
          my $_etype133 = 0;
          $xfer += $input->readListBegin(\$_etype133, \$_size130);
          for (my $_i134 = 0; $_i134 < $_size130; ++$_i134)
          {
            my $elem135 = undef;
            $xfer += $input->readI32(\$elem135);
            push(@{$self->{big_numbers}},$elem135);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('LargeDeltas');
  if (defined $self->{b1}) {
    $xfer += $output->writeFieldBegin('b1', TType::STRUCT, 1);
    $xfer += $self->{b1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{b10}) {
    $xfer += $output->writeFieldBegin('b10', TType::STRUCT, 10);
    $xfer += $self->{b10}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{b100}) {
    $xfer += $output->writeFieldBegin('b100', TType::STRUCT, 100);
    $xfer += $self->{b100}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{check_true}) {
    $xfer += $output->writeFieldBegin('check_true', TType::BOOL, 500);
    $xfer += $output->writeBool($self->{check_true});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{b1000}) {
    $xfer += $output->writeFieldBegin('b1000', TType::STRUCT, 1000);
    $xfer += $self->{b1000}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{check_false}) {
    $xfer += $output->writeFieldBegin('check_false', TType::BOOL, 1500);
    $xfer += $output->writeBool($self->{check_false});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{vertwo2000}) {
    $xfer += $output->writeFieldBegin('vertwo2000', TType::STRUCT, 2000);
    $xfer += $self->{vertwo2000}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{a_set2500}) {
    $xfer += $output->writeFieldBegin('a_set2500', TType::SET, 2500);
    {
      $xfer += $output->writeSetBegin(TType::STRING, scalar(@{$self->{a_set2500}}));
      {
        foreach my $iter136 (@{$self->{a_set2500}})
        {
          $xfer += $output->writeString($iter136);
        }
      }
      $xfer += $output->writeSetEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{vertwo3000}) {
    $xfer += $output->writeFieldBegin('vertwo3000', TType::STRUCT, 3000);
    $xfer += $self->{vertwo3000}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{big_numbers}) {
    $xfer += $output->writeFieldBegin('big_numbers', TType::LIST, 4000);
    {
      $xfer += $output->writeListBegin(TType::I32, scalar(@{$self->{big_numbers}}));
      {
        foreach my $iter137 (@{$self->{big_numbers}}) 
        {
          $xfer += $output->writeI32($iter137);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::NestedListsI32x2;
use base qw(Class::Accessor);
ThriftTest::NestedListsI32x2->mk_accessors( qw( integerlist ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{integerlist} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{integerlist}) {
      $self->{integerlist} = $vals->{integerlist};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NestedListsI32x2';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size138 = 0;
          $self->{integerlist} = [];
          my $_etype141 = 0;
          $xfer += $input->readListBegin(\$_etype141, \$_size138);
          for (my $_i142 = 0; $_i142 < $_size138; ++$_i142)
          {
            my $elem143 = undef;
            {
              my $_size144 = 0;
              $elem143 = [];
              my $_etype147 = 0;
              $xfer += $input->readListBegin(\$_etype147, \$_size144);
              for (my $_i148 = 0; $_i148 < $_size144; ++$_i148)
              {
                my $elem149 = undef;
                $xfer += $input->readI32(\$elem149);
                push(@{$elem143},$elem149);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{integerlist}},$elem143);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NestedListsI32x2');
  if (defined $self->{integerlist}) {
    $xfer += $output->writeFieldBegin('integerlist', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::LIST, scalar(@{$self->{integerlist}}));
      {
        foreach my $iter150 (@{$self->{integerlist}}) 
        {
          {
            $xfer += $output->writeListBegin(TType::I32, scalar(@{${iter150}}));
            {
              foreach my $iter151 (@{${iter150}}) 
              {
                $xfer += $output->writeI32($iter151);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::NestedListsI32x3;
use base qw(Class::Accessor);
ThriftTest::NestedListsI32x3->mk_accessors( qw( integerlist ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{integerlist} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{integerlist}) {
      $self->{integerlist} = $vals->{integerlist};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NestedListsI32x3';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size152 = 0;
          $self->{integerlist} = [];
          my $_etype155 = 0;
          $xfer += $input->readListBegin(\$_etype155, \$_size152);
          for (my $_i156 = 0; $_i156 < $_size152; ++$_i156)
          {
            my $elem157 = undef;
            {
              my $_size158 = 0;
              $elem157 = [];
              my $_etype161 = 0;
              $xfer += $input->readListBegin(\$_etype161, \$_size158);
              for (my $_i162 = 0; $_i162 < $_size158; ++$_i162)
              {
                my $elem163 = undef;
                {
                  my $_size164 = 0;
                  $elem163 = [];
                  my $_etype167 = 0;
                  $xfer += $input->readListBegin(\$_etype167, \$_size164);
                  for (my $_i168 = 0; $_i168 < $_size164; ++$_i168)
                  {
                    my $elem169 = undef;
                    $xfer += $input->readI32(\$elem169);
                    push(@{$elem163},$elem169);
                  }
                  $xfer += $input->readListEnd();
                }
                push(@{$elem157},$elem163);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{integerlist}},$elem157);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NestedListsI32x3');
  if (defined $self->{integerlist}) {
    $xfer += $output->writeFieldBegin('integerlist', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::LIST, scalar(@{$self->{integerlist}}));
      {
        foreach my $iter170 (@{$self->{integerlist}}) 
        {
          {
            $xfer += $output->writeListBegin(TType::LIST, scalar(@{${iter170}}));
            {
              foreach my $iter171 (@{${iter170}}) 
              {
                {
                  $xfer += $output->writeListBegin(TType::I32, scalar(@{${iter171}}));
                  {
                    foreach my $iter172 (@{${iter171}}) 
                    {
                      $xfer += $output->writeI32($iter172);
                    }
                  }
                  $xfer += $output->writeListEnd();
                }
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::NestedMixedx2;
use base qw(Class::Accessor);
ThriftTest::NestedMixedx2->mk_accessors( qw( int_set_list map_int_strset map_int_strset_list ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{int_set_list} = undef;
  $self->{map_int_strset} = undef;
  $self->{map_int_strset_list} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{int_set_list}) {
      $self->{int_set_list} = $vals->{int_set_list};
    }
    if (defined $vals->{map_int_strset}) {
      $self->{map_int_strset} = $vals->{map_int_strset};
    }
    if (defined $vals->{map_int_strset_list}) {
      $self->{map_int_strset_list} = $vals->{map_int_strset_list};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NestedMixedx2';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size173 = 0;
          $self->{int_set_list} = [];
          my $_etype176 = 0;
          $xfer += $input->readListBegin(\$_etype176, \$_size173);
          for (my $_i177 = 0; $_i177 < $_size173; ++$_i177)
          {
            my $elem178 = undef;
            {
              my $_size179 = 0;
              $elem178 = {};
              my $_etype182 = 0;
              $xfer += $input->readSetBegin(\$_etype182, \$_size179);
              for (my $_i183 = 0; $_i183 < $_size179; ++$_i183)
              {
                my $elem184 = undef;
                $xfer += $input->readI32(\$elem184);
                $elem178->{$elem184} = 1;
              }
              $xfer += $input->readSetEnd();
            }
            push(@{$self->{int_set_list}},$elem178);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size185 = 0;
          $self->{map_int_strset} = {};
          my $_ktype186 = 0;
          my $_vtype187 = 0;
          $xfer += $input->readMapBegin(\$_ktype186, \$_vtype187, \$_size185);
          for (my $_i189 = 0; $_i189 < $_size185; ++$_i189)
          {
            my $key190 = 0;
            my $val191 = [];
            $xfer += $input->readI32(\$key190);
            {
              my $_size192 = 0;
              $val191 = {};
              my $_etype195 = 0;
              $xfer += $input->readSetBegin(\$_etype195, \$_size192);
              for (my $_i196 = 0; $_i196 < $_size192; ++$_i196)
              {
                my $elem197 = undef;
                $xfer += $input->readString(\$elem197);
                $val191->{$elem197} = 1;
              }
              $xfer += $input->readSetEnd();
            }
            $self->{map_int_strset}->{$key190} = $val191;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size198 = 0;
          $self->{map_int_strset_list} = [];
          my $_etype201 = 0;
          $xfer += $input->readListBegin(\$_etype201, \$_size198);
          for (my $_i202 = 0; $_i202 < $_size198; ++$_i202)
          {
            my $elem203 = undef;
            {
              my $_size204 = 0;
              $elem203 = {};
              my $_ktype205 = 0;
              my $_vtype206 = 0;
              $xfer += $input->readMapBegin(\$_ktype205, \$_vtype206, \$_size204);
              for (my $_i208 = 0; $_i208 < $_size204; ++$_i208)
              {
                my $key209 = 0;
                my $val210 = [];
                $xfer += $input->readI32(\$key209);
                {
                  my $_size211 = 0;
                  $val210 = {};
                  my $_etype214 = 0;
                  $xfer += $input->readSetBegin(\$_etype214, \$_size211);
                  for (my $_i215 = 0; $_i215 < $_size211; ++$_i215)
                  {
                    my $elem216 = undef;
                    $xfer += $input->readString(\$elem216);
                    $val210->{$elem216} = 1;
                  }
                  $xfer += $input->readSetEnd();
                }
                $elem203->{$key209} = $val210;
              }
              $xfer += $input->readMapEnd();
            }
            push(@{$self->{map_int_strset_list}},$elem203);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NestedMixedx2');
  if (defined $self->{int_set_list}) {
    $xfer += $output->writeFieldBegin('int_set_list', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::SET, scalar(@{$self->{int_set_list}}));
      {
        foreach my $iter217 (@{$self->{int_set_list}}) 
        {
          {
            $xfer += $output->writeSetBegin(TType::I32, scalar(@{${iter217}}));
            {
              foreach my $iter218 (@{${iter217}})
              {
                $xfer += $output->writeI32($iter218);
              }
            }
            $xfer += $output->writeSetEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{map_int_strset}) {
    $xfer += $output->writeFieldBegin('map_int_strset', TType::MAP, 2);
    {
      $xfer += $output->writeMapBegin(TType::I32, TType::SET, scalar(keys %{$self->{map_int_strset}}));
      {
        while( my ($kiter219,$viter220) = each %{$self->{map_int_strset}}) 
        {
          $xfer += $output->writeI32($kiter219);
          {
            $xfer += $output->writeSetBegin(TType::STRING, scalar(@{${viter220}}));
            {
              foreach my $iter221 (@{${viter220}})
              {
                $xfer += $output->writeString($iter221);
              }
            }
            $xfer += $output->writeSetEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{map_int_strset_list}) {
    $xfer += $output->writeFieldBegin('map_int_strset_list', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::MAP, scalar(@{$self->{map_int_strset_list}}));
      {
        foreach my $iter222 (@{$self->{map_int_strset_list}}) 
        {
          {
            $xfer += $output->writeMapBegin(TType::I32, TType::SET, scalar(keys %{${iter222}}));
            {
              while( my ($kiter223,$viter224) = each %{${iter222}}) 
              {
                $xfer += $output->writeI32($kiter223);
                {
                  $xfer += $output->writeSetBegin(TType::STRING, scalar(@{${viter224}}));
                  {
                    foreach my $iter225 (@{${viter224}})
                    {
                      $xfer += $output->writeString($iter225);
                    }
                  }
                  $xfer += $output->writeSetEnd();
                }
              }
            }
            $xfer += $output->writeMapEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ListBonks;
use base qw(Class::Accessor);
ThriftTest::ListBonks->mk_accessors( qw( bonk ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{bonk} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{bonk}) {
      $self->{bonk} = $vals->{bonk};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ListBonks';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size226 = 0;
          $self->{bonk} = [];
          my $_etype229 = 0;
          $xfer += $input->readListBegin(\$_etype229, \$_size226);
          for (my $_i230 = 0; $_i230 < $_size226; ++$_i230)
          {
            my $elem231 = undef;
            $elem231 = new ThriftTest::Bonk();
            $xfer += $elem231->read($input);
            push(@{$self->{bonk}},$elem231);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ListBonks');
  if (defined $self->{bonk}) {
    $xfer += $output->writeFieldBegin('bonk', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{bonk}}));
      {
        foreach my $iter232 (@{$self->{bonk}}) 
        {
          $xfer += ${iter232}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::NestedListsBonk;
use base qw(Class::Accessor);
ThriftTest::NestedListsBonk->mk_accessors( qw( bonk ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{bonk} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{bonk}) {
      $self->{bonk} = $vals->{bonk};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NestedListsBonk';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size233 = 0;
          $self->{bonk} = [];
          my $_etype236 = 0;
          $xfer += $input->readListBegin(\$_etype236, \$_size233);
          for (my $_i237 = 0; $_i237 < $_size233; ++$_i237)
          {
            my $elem238 = undef;
            {
              my $_size239 = 0;
              $elem238 = [];
              my $_etype242 = 0;
              $xfer += $input->readListBegin(\$_etype242, \$_size239);
              for (my $_i243 = 0; $_i243 < $_size239; ++$_i243)
              {
                my $elem244 = undef;
                {
                  my $_size245 = 0;
                  $elem244 = [];
                  my $_etype248 = 0;
                  $xfer += $input->readListBegin(\$_etype248, \$_size245);
                  for (my $_i249 = 0; $_i249 < $_size245; ++$_i249)
                  {
                    my $elem250 = undef;
                    $elem250 = new ThriftTest::Bonk();
                    $xfer += $elem250->read($input);
                    push(@{$elem244},$elem250);
                  }
                  $xfer += $input->readListEnd();
                }
                push(@{$elem238},$elem244);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{bonk}},$elem238);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NestedListsBonk');
  if (defined $self->{bonk}) {
    $xfer += $output->writeFieldBegin('bonk', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::LIST, scalar(@{$self->{bonk}}));
      {
        foreach my $iter251 (@{$self->{bonk}}) 
        {
          {
            $xfer += $output->writeListBegin(TType::LIST, scalar(@{${iter251}}));
            {
              foreach my $iter252 (@{${iter251}}) 
              {
                {
                  $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{${iter252}}));
                  {
                    foreach my $iter253 (@{${iter252}}) 
                    {
                      $xfer += ${iter253}->write($output);
                    }
                  }
                  $xfer += $output->writeListEnd();
                }
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::BoolTest;
use base qw(Class::Accessor);
ThriftTest::BoolTest->mk_accessors( qw( b s ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{b} = 1;
  $self->{s} = "true";
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{b}) {
      $self->{b} = $vals->{b};
    }
    if (defined $vals->{s}) {
      $self->{s} = $vals->{s};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'BoolTest';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{b});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{s});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('BoolTest');
  if (defined $self->{b}) {
    $xfer += $output->writeFieldBegin('b', TType::BOOL, 1);
    $xfer += $output->writeBool($self->{b});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{s}) {
    $xfer += $output->writeFieldBegin('s', TType::STRING, 2);
    $xfer += $output->writeString($self->{s});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::StructA;
use base qw(Class::Accessor);
ThriftTest::StructA->mk_accessors( qw( s ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{s} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{s}) {
      $self->{s} = $vals->{s};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StructA';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{s});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StructA');
  if (defined $self->{s}) {
    $xfer += $output->writeFieldBegin('s', TType::STRING, 1);
    $xfer += $output->writeString($self->{s});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::StructB;
use base qw(Class::Accessor);
ThriftTest::StructB->mk_accessors( qw( aa ab ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{aa} = undef;
  $self->{ab} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{aa}) {
      $self->{aa} = $vals->{aa};
    }
    if (defined $vals->{ab}) {
      $self->{ab} = $vals->{ab};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StructB';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{aa} = new ThriftTest::StructA();
        $xfer += $self->{aa}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ab} = new ThriftTest::StructA();
        $xfer += $self->{ab}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StructB');
  if (defined $self->{aa}) {
    $xfer += $output->writeFieldBegin('aa', TType::STRUCT, 1);
    $xfer += $self->{aa}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ab}) {
    $xfer += $output->writeFieldBegin('ab', TType::STRUCT, 2);
    $xfer += $self->{ab}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

1;
