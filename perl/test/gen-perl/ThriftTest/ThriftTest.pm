#
# Autogenerated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

use ThriftTest::Types;

# HELPER FUNCTIONS AND STRUCTURES

package ThriftTest::ThriftTest_testVoid_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testVoid_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testVoid_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testVoid_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testVoid_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testVoid_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testString_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testString_args->mk_accessors( qw( thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{thing}) {
      $self->{thing} = $vals->{thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testString_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testString_args');
  if (defined $self->{thing}) {
    $xfer += $output->writeFieldBegin('thing', TType::STRING, 1);
    $xfer += $output->writeString($self->{thing});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testString_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testString_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testString_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testString_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testByte_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testByte_args->mk_accessors( qw( thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{thing}) {
      $self->{thing} = $vals->{thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testByte_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testByte_args');
  if (defined $self->{thing}) {
    $xfer += $output->writeFieldBegin('thing', TType::BYTE, 1);
    $xfer += $output->writeByte($self->{thing});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testByte_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testByte_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testByte_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testByte_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BYTE, 0);
    $xfer += $output->writeByte($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testI32_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testI32_args->mk_accessors( qw( thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{thing}) {
      $self->{thing} = $vals->{thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testI32_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testI32_args');
  if (defined $self->{thing}) {
    $xfer += $output->writeFieldBegin('thing', TType::I32, 1);
    $xfer += $output->writeI32($self->{thing});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testI32_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testI32_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testI32_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testI32_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testI64_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testI64_args->mk_accessors( qw( thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{thing}) {
      $self->{thing} = $vals->{thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testI64_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testI64_args');
  if (defined $self->{thing}) {
    $xfer += $output->writeFieldBegin('thing', TType::I64, 1);
    $xfer += $output->writeI64($self->{thing});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testI64_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testI64_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testI64_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testI64_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testDouble_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testDouble_args->mk_accessors( qw( thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{thing}) {
      $self->{thing} = $vals->{thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testDouble_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testDouble_args');
  if (defined $self->{thing}) {
    $xfer += $output->writeFieldBegin('thing', TType::DOUBLE, 1);
    $xfer += $output->writeDouble($self->{thing});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testDouble_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testDouble_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testDouble_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testDouble_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::DOUBLE, 0);
    $xfer += $output->writeDouble($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testStruct_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testStruct_args->mk_accessors( qw( thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{thing}) {
      $self->{thing} = $vals->{thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testStruct_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{thing} = new ThriftTest::Xtruct();
        $xfer += $self->{thing}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testStruct_args');
  if (defined $self->{thing}) {
    $xfer += $output->writeFieldBegin('thing', TType::STRUCT, 1);
    $xfer += $self->{thing}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testStruct_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testStruct_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testStruct_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new ThriftTest::Xtruct();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testStruct_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testNest_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testNest_args->mk_accessors( qw( thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{thing}) {
      $self->{thing} = $vals->{thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testNest_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{thing} = new ThriftTest::Xtruct2();
        $xfer += $self->{thing}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testNest_args');
  if (defined $self->{thing}) {
    $xfer += $output->writeFieldBegin('thing', TType::STRUCT, 1);
    $xfer += $self->{thing}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testNest_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testNest_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testNest_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new ThriftTest::Xtruct2();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testNest_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testMap_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testMap_args->mk_accessors( qw( thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{thing}) {
      $self->{thing} = $vals->{thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testMap_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size254 = 0;
          $self->{thing} = {};
          my $_ktype255 = 0;
          my $_vtype256 = 0;
          $xfer += $input->readMapBegin(\$_ktype255, \$_vtype256, \$_size254);
          for (my $_i258 = 0; $_i258 < $_size254; ++$_i258)
          {
            my $key259 = 0;
            my $val260 = 0;
            $xfer += $input->readI32(\$key259);
            $xfer += $input->readI32(\$val260);
            $self->{thing}->{$key259} = $val260;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testMap_args');
  if (defined $self->{thing}) {
    $xfer += $output->writeFieldBegin('thing', TType::MAP, 1);
    {
      $xfer += $output->writeMapBegin(TType::I32, TType::I32, scalar(keys %{$self->{thing}}));
      {
        while( my ($kiter261,$viter262) = each %{$self->{thing}}) 
        {
          $xfer += $output->writeI32($kiter261);
          $xfer += $output->writeI32($viter262);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testMap_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testMap_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testMap_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size263 = 0;
          $self->{success} = {};
          my $_ktype264 = 0;
          my $_vtype265 = 0;
          $xfer += $input->readMapBegin(\$_ktype264, \$_vtype265, \$_size263);
          for (my $_i267 = 0; $_i267 < $_size263; ++$_i267)
          {
            my $key268 = 0;
            my $val269 = 0;
            $xfer += $input->readI32(\$key268);
            $xfer += $input->readI32(\$val269);
            $self->{success}->{$key268} = $val269;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testMap_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(TType::I32, TType::I32, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter270,$viter271) = each %{$self->{success}}) 
        {
          $xfer += $output->writeI32($kiter270);
          $xfer += $output->writeI32($viter271);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testStringMap_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testStringMap_args->mk_accessors( qw( thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{thing}) {
      $self->{thing} = $vals->{thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testStringMap_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size272 = 0;
          $self->{thing} = {};
          my $_ktype273 = 0;
          my $_vtype274 = 0;
          $xfer += $input->readMapBegin(\$_ktype273, \$_vtype274, \$_size272);
          for (my $_i276 = 0; $_i276 < $_size272; ++$_i276)
          {
            my $key277 = '';
            my $val278 = '';
            $xfer += $input->readString(\$key277);
            $xfer += $input->readString(\$val278);
            $self->{thing}->{$key277} = $val278;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testStringMap_args');
  if (defined $self->{thing}) {
    $xfer += $output->writeFieldBegin('thing', TType::MAP, 1);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{thing}}));
      {
        while( my ($kiter279,$viter280) = each %{$self->{thing}}) 
        {
          $xfer += $output->writeString($kiter279);
          $xfer += $output->writeString($viter280);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testStringMap_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testStringMap_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testStringMap_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size281 = 0;
          $self->{success} = {};
          my $_ktype282 = 0;
          my $_vtype283 = 0;
          $xfer += $input->readMapBegin(\$_ktype282, \$_vtype283, \$_size281);
          for (my $_i285 = 0; $_i285 < $_size281; ++$_i285)
          {
            my $key286 = '';
            my $val287 = '';
            $xfer += $input->readString(\$key286);
            $xfer += $input->readString(\$val287);
            $self->{success}->{$key286} = $val287;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testStringMap_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter288,$viter289) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter288);
          $xfer += $output->writeString($viter289);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testSet_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testSet_args->mk_accessors( qw( thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{thing}) {
      $self->{thing} = $vals->{thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testSet_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::SET) {
        {
          my $_size290 = 0;
          $self->{thing} = {};
          my $_etype293 = 0;
          $xfer += $input->readSetBegin(\$_etype293, \$_size290);
          for (my $_i294 = 0; $_i294 < $_size290; ++$_i294)
          {
            my $elem295 = undef;
            $xfer += $input->readI32(\$elem295);
            $self->{thing}->{$elem295} = 1;
          }
          $xfer += $input->readSetEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testSet_args');
  if (defined $self->{thing}) {
    $xfer += $output->writeFieldBegin('thing', TType::SET, 1);
    {
      $xfer += $output->writeSetBegin(TType::I32, scalar(@{$self->{thing}}));
      {
        foreach my $iter296 (@{$self->{thing}})
        {
          $xfer += $output->writeI32($iter296);
        }
      }
      $xfer += $output->writeSetEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testSet_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testSet_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testSet_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::SET) {
        {
          my $_size297 = 0;
          $self->{success} = {};
          my $_etype300 = 0;
          $xfer += $input->readSetBegin(\$_etype300, \$_size297);
          for (my $_i301 = 0; $_i301 < $_size297; ++$_i301)
          {
            my $elem302 = undef;
            $xfer += $input->readI32(\$elem302);
            $self->{success}->{$elem302} = 1;
          }
          $xfer += $input->readSetEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testSet_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::SET, 0);
    {
      $xfer += $output->writeSetBegin(TType::I32, scalar(@{$self->{success}}));
      {
        foreach my $iter303 (@{$self->{success}})
        {
          $xfer += $output->writeI32($iter303);
        }
      }
      $xfer += $output->writeSetEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testList_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testList_args->mk_accessors( qw( thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{thing}) {
      $self->{thing} = $vals->{thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testList_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size304 = 0;
          $self->{thing} = [];
          my $_etype307 = 0;
          $xfer += $input->readListBegin(\$_etype307, \$_size304);
          for (my $_i308 = 0; $_i308 < $_size304; ++$_i308)
          {
            my $elem309 = undef;
            $xfer += $input->readI32(\$elem309);
            push(@{$self->{thing}},$elem309);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testList_args');
  if (defined $self->{thing}) {
    $xfer += $output->writeFieldBegin('thing', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::I32, scalar(@{$self->{thing}}));
      {
        foreach my $iter310 (@{$self->{thing}}) 
        {
          $xfer += $output->writeI32($iter310);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testList_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testList_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testList_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size311 = 0;
          $self->{success} = [];
          my $_etype314 = 0;
          $xfer += $input->readListBegin(\$_etype314, \$_size311);
          for (my $_i315 = 0; $_i315 < $_size311; ++$_i315)
          {
            my $elem316 = undef;
            $xfer += $input->readI32(\$elem316);
            push(@{$self->{success}},$elem316);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testList_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::I32, scalar(@{$self->{success}}));
      {
        foreach my $iter317 (@{$self->{success}}) 
        {
          $xfer += $output->writeI32($iter317);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testEnum_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testEnum_args->mk_accessors( qw( thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{thing}) {
      $self->{thing} = $vals->{thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testEnum_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testEnum_args');
  if (defined $self->{thing}) {
    $xfer += $output->writeFieldBegin('thing', TType::I32, 1);
    $xfer += $output->writeI32($self->{thing});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testEnum_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testEnum_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testEnum_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testEnum_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testTypedef_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testTypedef_args->mk_accessors( qw( thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{thing}) {
      $self->{thing} = $vals->{thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testTypedef_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testTypedef_args');
  if (defined $self->{thing}) {
    $xfer += $output->writeFieldBegin('thing', TType::I64, 1);
    $xfer += $output->writeI64($self->{thing});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testTypedef_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testTypedef_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testTypedef_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testTypedef_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testMapMap_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testMapMap_args->mk_accessors( qw( hello ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{hello} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{hello}) {
      $self->{hello} = $vals->{hello};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testMapMap_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{hello});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testMapMap_args');
  if (defined $self->{hello}) {
    $xfer += $output->writeFieldBegin('hello', TType::I32, 1);
    $xfer += $output->writeI32($self->{hello});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testMapMap_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testMapMap_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testMapMap_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size318 = 0;
          $self->{success} = {};
          my $_ktype319 = 0;
          my $_vtype320 = 0;
          $xfer += $input->readMapBegin(\$_ktype319, \$_vtype320, \$_size318);
          for (my $_i322 = 0; $_i322 < $_size318; ++$_i322)
          {
            my $key323 = 0;
            my $val324 = [];
            $xfer += $input->readI32(\$key323);
            {
              my $_size325 = 0;
              $val324 = {};
              my $_ktype326 = 0;
              my $_vtype327 = 0;
              $xfer += $input->readMapBegin(\$_ktype326, \$_vtype327, \$_size325);
              for (my $_i329 = 0; $_i329 < $_size325; ++$_i329)
              {
                my $key330 = 0;
                my $val331 = 0;
                $xfer += $input->readI32(\$key330);
                $xfer += $input->readI32(\$val331);
                $val324->{$key330} = $val331;
              }
              $xfer += $input->readMapEnd();
            }
            $self->{success}->{$key323} = $val324;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testMapMap_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(TType::I32, TType::MAP, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter332,$viter333) = each %{$self->{success}}) 
        {
          $xfer += $output->writeI32($kiter332);
          {
            $xfer += $output->writeMapBegin(TType::I32, TType::I32, scalar(keys %{${viter333}}));
            {
              while( my ($kiter334,$viter335) = each %{${viter333}}) 
              {
                $xfer += $output->writeI32($kiter334);
                $xfer += $output->writeI32($viter335);
              }
            }
            $xfer += $output->writeMapEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testInsanity_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testInsanity_args->mk_accessors( qw( argument ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{argument} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{argument}) {
      $self->{argument} = $vals->{argument};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testInsanity_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{argument} = new ThriftTest::Insanity();
        $xfer += $self->{argument}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testInsanity_args');
  if (defined $self->{argument}) {
    $xfer += $output->writeFieldBegin('argument', TType::STRUCT, 1);
    $xfer += $self->{argument}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testInsanity_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testInsanity_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testInsanity_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size336 = 0;
          $self->{success} = {};
          my $_ktype337 = 0;
          my $_vtype338 = 0;
          $xfer += $input->readMapBegin(\$_ktype337, \$_vtype338, \$_size336);
          for (my $_i340 = 0; $_i340 < $_size336; ++$_i340)
          {
            my $key341 = 0;
            my $val342 = [];
            $xfer += $input->readI64(\$key341);
            {
              my $_size343 = 0;
              $val342 = {};
              my $_ktype344 = 0;
              my $_vtype345 = 0;
              $xfer += $input->readMapBegin(\$_ktype344, \$_vtype345, \$_size343);
              for (my $_i347 = 0; $_i347 < $_size343; ++$_i347)
              {
                my $key348 = 0;
                my $val349 = new ThriftTest::Insanity();
                $xfer += $input->readI32(\$key348);
                $val349 = new ThriftTest::Insanity();
                $xfer += $val349->read($input);
                $val342->{$key348} = $val349;
              }
              $xfer += $input->readMapEnd();
            }
            $self->{success}->{$key341} = $val342;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testInsanity_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(TType::I64, TType::MAP, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter350,$viter351) = each %{$self->{success}}) 
        {
          $xfer += $output->writeI64($kiter350);
          {
            $xfer += $output->writeMapBegin(TType::I32, TType::STRUCT, scalar(keys %{${viter351}}));
            {
              while( my ($kiter352,$viter353) = each %{${viter351}}) 
              {
                $xfer += $output->writeI32($kiter352);
                $xfer += ${viter353}->write($output);
              }
            }
            $xfer += $output->writeMapEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testMulti_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testMulti_args->mk_accessors( qw( arg0 arg1 arg2 arg3 arg4 arg5 ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{arg0} = undef;
  $self->{arg1} = undef;
  $self->{arg2} = undef;
  $self->{arg3} = undef;
  $self->{arg4} = undef;
  $self->{arg5} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{arg0}) {
      $self->{arg0} = $vals->{arg0};
    }
    if (defined $vals->{arg1}) {
      $self->{arg1} = $vals->{arg1};
    }
    if (defined $vals->{arg2}) {
      $self->{arg2} = $vals->{arg2};
    }
    if (defined $vals->{arg3}) {
      $self->{arg3} = $vals->{arg3};
    }
    if (defined $vals->{arg4}) {
      $self->{arg4} = $vals->{arg4};
    }
    if (defined $vals->{arg5}) {
      $self->{arg5} = $vals->{arg5};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testMulti_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{arg0});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{arg1});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{arg2});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size354 = 0;
          $self->{arg3} = {};
          my $_ktype355 = 0;
          my $_vtype356 = 0;
          $xfer += $input->readMapBegin(\$_ktype355, \$_vtype356, \$_size354);
          for (my $_i358 = 0; $_i358 < $_size354; ++$_i358)
          {
            my $key359 = 0;
            my $val360 = '';
            $xfer += $input->readI16(\$key359);
            $xfer += $input->readString(\$val360);
            $self->{arg3}->{$key359} = $val360;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{arg4});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{arg5});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testMulti_args');
  if (defined $self->{arg0}) {
    $xfer += $output->writeFieldBegin('arg0', TType::BYTE, 1);
    $xfer += $output->writeByte($self->{arg0});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{arg1}) {
    $xfer += $output->writeFieldBegin('arg1', TType::I32, 2);
    $xfer += $output->writeI32($self->{arg1});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{arg2}) {
    $xfer += $output->writeFieldBegin('arg2', TType::I64, 3);
    $xfer += $output->writeI64($self->{arg2});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{arg3}) {
    $xfer += $output->writeFieldBegin('arg3', TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(TType::I16, TType::STRING, scalar(keys %{$self->{arg3}}));
      {
        while( my ($kiter361,$viter362) = each %{$self->{arg3}}) 
        {
          $xfer += $output->writeI16($kiter361);
          $xfer += $output->writeString($viter362);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{arg4}) {
    $xfer += $output->writeFieldBegin('arg4', TType::I32, 5);
    $xfer += $output->writeI32($self->{arg4});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{arg5}) {
    $xfer += $output->writeFieldBegin('arg5', TType::I64, 6);
    $xfer += $output->writeI64($self->{arg5});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testMulti_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testMulti_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testMulti_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new ThriftTest::Xtruct();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testMulti_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testException_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testException_args->mk_accessors( qw( arg ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{arg} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{arg}) {
      $self->{arg} = $vals->{arg};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testException_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{arg});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testException_args');
  if (defined $self->{arg}) {
    $xfer += $output->writeFieldBegin('arg', TType::STRING, 1);
    $xfer += $output->writeString($self->{arg});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testException_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testException_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{err1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{err1}) {
      $self->{err1} = $vals->{err1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testException_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{err1} = new ThriftTest::Xception();
        $xfer += $self->{err1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testException_result');
  if (defined $self->{err1}) {
    $xfer += $output->writeFieldBegin('err1', TType::STRUCT, 1);
    $xfer += $self->{err1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testMultiException_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testMultiException_args->mk_accessors( qw( arg0 arg1 ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{arg0} = undef;
  $self->{arg1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{arg0}) {
      $self->{arg0} = $vals->{arg0};
    }
    if (defined $vals->{arg1}) {
      $self->{arg1} = $vals->{arg1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testMultiException_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{arg0});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{arg1});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testMultiException_args');
  if (defined $self->{arg0}) {
    $xfer += $output->writeFieldBegin('arg0', TType::STRING, 1);
    $xfer += $output->writeString($self->{arg0});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{arg1}) {
    $xfer += $output->writeFieldBegin('arg1', TType::STRING, 2);
    $xfer += $output->writeString($self->{arg1});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testMultiException_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testMultiException_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{err1} = undef;
  $self->{err2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{err1}) {
      $self->{err1} = $vals->{err1};
    }
    if (defined $vals->{err2}) {
      $self->{err2} = $vals->{err2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testMultiException_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new ThriftTest::Xtruct();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{err1} = new ThriftTest::Xception();
        $xfer += $self->{err1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{err2} = new ThriftTest::Xception2();
        $xfer += $self->{err2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testMultiException_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{err1}) {
    $xfer += $output->writeFieldBegin('err1', TType::STRUCT, 1);
    $xfer += $self->{err1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{err2}) {
    $xfer += $output->writeFieldBegin('err2', TType::STRUCT, 2);
    $xfer += $self->{err2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testOneway_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testOneway_args->mk_accessors( qw( secondsToSleep ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{secondsToSleep} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{secondsToSleep}) {
      $self->{secondsToSleep} = $vals->{secondsToSleep};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testOneway_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{secondsToSleep});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testOneway_args');
  if (defined $self->{secondsToSleep}) {
    $xfer += $output->writeFieldBegin('secondsToSleep', TType::I32, 1);
    $xfer += $output->writeI32($self->{secondsToSleep});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testOneway_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testOneway_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testOneway_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTestIf;

use strict;


sub testVoid{
  my $self = shift;

  die 'implement interface';
}

sub testString{
  my $self = shift;
  my $thing = shift;

  die 'implement interface';
}

sub testByte{
  my $self = shift;
  my $thing = shift;

  die 'implement interface';
}

sub testI32{
  my $self = shift;
  my $thing = shift;

  die 'implement interface';
}

sub testI64{
  my $self = shift;
  my $thing = shift;

  die 'implement interface';
}

sub testDouble{
  my $self = shift;
  my $thing = shift;

  die 'implement interface';
}

sub testStruct{
  my $self = shift;
  my $thing = shift;

  die 'implement interface';
}

sub testNest{
  my $self = shift;
  my $thing = shift;

  die 'implement interface';
}

sub testMap{
  my $self = shift;
  my $thing = shift;

  die 'implement interface';
}

sub testStringMap{
  my $self = shift;
  my $thing = shift;

  die 'implement interface';
}

sub testSet{
  my $self = shift;
  my $thing = shift;

  die 'implement interface';
}

sub testList{
  my $self = shift;
  my $thing = shift;

  die 'implement interface';
}

sub testEnum{
  my $self = shift;
  my $thing = shift;

  die 'implement interface';
}

sub testTypedef{
  my $self = shift;
  my $thing = shift;

  die 'implement interface';
}

sub testMapMap{
  my $self = shift;
  my $hello = shift;

  die 'implement interface';
}

sub testInsanity{
  my $self = shift;
  my $argument = shift;

  die 'implement interface';
}

sub testMulti{
  my $self = shift;
  my $arg0 = shift;
  my $arg1 = shift;
  my $arg2 = shift;
  my $arg3 = shift;
  my $arg4 = shift;
  my $arg5 = shift;

  die 'implement interface';
}

sub testException{
  my $self = shift;
  my $arg = shift;

  die 'implement interface';
}

sub testMultiException{
  my $self = shift;
  my $arg0 = shift;
  my $arg1 = shift;

  die 'implement interface';
}

sub testOneway{
  my $self = shift;
  my $secondsToSleep = shift;

  die 'implement interface';
}

package ThriftTest::ThriftTestRest;

use strict;


sub new {
  my ($classname, $impl) = @_;
  my $self     ={ impl => $impl };

  return bless($self,$classname);
}

sub testVoid{
  my ($self, $request) = @_;

  return $self->{impl}->testVoid();
}

sub testString{
  my ($self, $request) = @_;

  my $thing = ($request->{'thing'}) ? $request->{'thing'} : undef;
  return $self->{impl}->testString($thing);
}

sub testByte{
  my ($self, $request) = @_;

  my $thing = ($request->{'thing'}) ? $request->{'thing'} : undef;
  return $self->{impl}->testByte($thing);
}

sub testI32{
  my ($self, $request) = @_;

  my $thing = ($request->{'thing'}) ? $request->{'thing'} : undef;
  return $self->{impl}->testI32($thing);
}

sub testI64{
  my ($self, $request) = @_;

  my $thing = ($request->{'thing'}) ? $request->{'thing'} : undef;
  return $self->{impl}->testI64($thing);
}

sub testDouble{
  my ($self, $request) = @_;

  my $thing = ($request->{'thing'}) ? $request->{'thing'} : undef;
  return $self->{impl}->testDouble($thing);
}

sub testStruct{
  my ($self, $request) = @_;

  my $thing = ($request->{'thing'}) ? $request->{'thing'} : undef;
  return $self->{impl}->testStruct($thing);
}

sub testNest{
  my ($self, $request) = @_;

  my $thing = ($request->{'thing'}) ? $request->{'thing'} : undef;
  return $self->{impl}->testNest($thing);
}

sub testMap{
  my ($self, $request) = @_;

  my $thing = ($request->{'thing'}) ? $request->{'thing'} : undef;
  return $self->{impl}->testMap($thing);
}

sub testStringMap{
  my ($self, $request) = @_;

  my $thing = ($request->{'thing'}) ? $request->{'thing'} : undef;
  return $self->{impl}->testStringMap($thing);
}

sub testSet{
  my ($self, $request) = @_;

  my $thing = ($request->{'thing'}) ? $request->{'thing'} : undef;
  return $self->{impl}->testSet($thing);
}

sub testList{
  my ($self, $request) = @_;

  my $thing = ($request->{'thing'}) ? $request->{'thing'} : undef;
  return $self->{impl}->testList($thing);
}

sub testEnum{
  my ($self, $request) = @_;

  my $thing = ($request->{'thing'}) ? $request->{'thing'} : undef;
  return $self->{impl}->testEnum($thing);
}

sub testTypedef{
  my ($self, $request) = @_;

  my $thing = ($request->{'thing'}) ? $request->{'thing'} : undef;
  return $self->{impl}->testTypedef($thing);
}

sub testMapMap{
  my ($self, $request) = @_;

  my $hello = ($request->{'hello'}) ? $request->{'hello'} : undef;
  return $self->{impl}->testMapMap($hello);
}

sub testInsanity{
  my ($self, $request) = @_;

  my $argument = ($request->{'argument'}) ? $request->{'argument'} : undef;
  return $self->{impl}->testInsanity($argument);
}

sub testMulti{
  my ($self, $request) = @_;

  my $arg0 = ($request->{'arg0'}) ? $request->{'arg0'} : undef;
  my $arg1 = ($request->{'arg1'}) ? $request->{'arg1'} : undef;
  my $arg2 = ($request->{'arg2'}) ? $request->{'arg2'} : undef;
  my $arg3 = ($request->{'arg3'}) ? $request->{'arg3'} : undef;
  my $arg4 = ($request->{'arg4'}) ? $request->{'arg4'} : undef;
  my $arg5 = ($request->{'arg5'}) ? $request->{'arg5'} : undef;
  return $self->{impl}->testMulti($arg0, $arg1, $arg2, $arg3, $arg4, $arg5);
}

sub testException{
  my ($self, $request) = @_;

  my $arg = ($request->{'arg'}) ? $request->{'arg'} : undef;
  return $self->{impl}->testException($arg);
}

sub testMultiException{
  my ($self, $request) = @_;

  my $arg0 = ($request->{'arg0'}) ? $request->{'arg0'} : undef;
  my $arg1 = ($request->{'arg1'}) ? $request->{'arg1'} : undef;
  return $self->{impl}->testMultiException($arg0, $arg1);
}

sub testOneway{
  my ($self, $request) = @_;

  my $secondsToSleep = ($request->{'secondsToSleep'}) ? $request->{'secondsToSleep'} : undef;
  return $self->{impl}->testOneway($secondsToSleep);
}

package ThriftTest::ThriftTestClient;


use base qw(ThriftTest::ThriftTestIf);
sub new {
  my ($classname, $input, $output) = @_;
  my $self      = {};
  $self->{input}  = $input;
  $self->{output} = defined $output ? $output : $input;
  $self->{seqid}  = 0;
  return bless($self,$classname);
}

sub testVoid{
  my $self = shift;

    $self->send_testVoid();
  $self->recv_testVoid();
}

sub send_testVoid{
  my $self = shift;

  $self->{output}->writeMessageBegin('testVoid', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftTest::ThriftTest_testVoid_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testVoid{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftTest::ThriftTest_testVoid_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub testString{
  my $self = shift;
  my $thing = shift;

    $self->send_testString($thing);
  return $self->recv_testString();
}

sub send_testString{
  my $self = shift;
  my $thing = shift;

  $self->{output}->writeMessageBegin('testString', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftTest::ThriftTest_testString_args();
  $args->{thing} = $thing;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testString{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftTest::ThriftTest_testString_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testString failed: unknown result";
}
sub testByte{
  my $self = shift;
  my $thing = shift;

    $self->send_testByte($thing);
  return $self->recv_testByte();
}

sub send_testByte{
  my $self = shift;
  my $thing = shift;

  $self->{output}->writeMessageBegin('testByte', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftTest::ThriftTest_testByte_args();
  $args->{thing} = $thing;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testByte{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftTest::ThriftTest_testByte_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testByte failed: unknown result";
}
sub testI32{
  my $self = shift;
  my $thing = shift;

    $self->send_testI32($thing);
  return $self->recv_testI32();
}

sub send_testI32{
  my $self = shift;
  my $thing = shift;

  $self->{output}->writeMessageBegin('testI32', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftTest::ThriftTest_testI32_args();
  $args->{thing} = $thing;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testI32{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftTest::ThriftTest_testI32_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testI32 failed: unknown result";
}
sub testI64{
  my $self = shift;
  my $thing = shift;

    $self->send_testI64($thing);
  return $self->recv_testI64();
}

sub send_testI64{
  my $self = shift;
  my $thing = shift;

  $self->{output}->writeMessageBegin('testI64', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftTest::ThriftTest_testI64_args();
  $args->{thing} = $thing;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testI64{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftTest::ThriftTest_testI64_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testI64 failed: unknown result";
}
sub testDouble{
  my $self = shift;
  my $thing = shift;

    $self->send_testDouble($thing);
  return $self->recv_testDouble();
}

sub send_testDouble{
  my $self = shift;
  my $thing = shift;

  $self->{output}->writeMessageBegin('testDouble', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftTest::ThriftTest_testDouble_args();
  $args->{thing} = $thing;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testDouble{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftTest::ThriftTest_testDouble_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testDouble failed: unknown result";
}
sub testStruct{
  my $self = shift;
  my $thing = shift;

    $self->send_testStruct($thing);
  return $self->recv_testStruct();
}

sub send_testStruct{
  my $self = shift;
  my $thing = shift;

  $self->{output}->writeMessageBegin('testStruct', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftTest::ThriftTest_testStruct_args();
  $args->{thing} = $thing;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testStruct{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftTest::ThriftTest_testStruct_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testStruct failed: unknown result";
}
sub testNest{
  my $self = shift;
  my $thing = shift;

    $self->send_testNest($thing);
  return $self->recv_testNest();
}

sub send_testNest{
  my $self = shift;
  my $thing = shift;

  $self->{output}->writeMessageBegin('testNest', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftTest::ThriftTest_testNest_args();
  $args->{thing} = $thing;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testNest{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftTest::ThriftTest_testNest_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testNest failed: unknown result";
}
sub testMap{
  my $self = shift;
  my $thing = shift;

    $self->send_testMap($thing);
  return $self->recv_testMap();
}

sub send_testMap{
  my $self = shift;
  my $thing = shift;

  $self->{output}->writeMessageBegin('testMap', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftTest::ThriftTest_testMap_args();
  $args->{thing} = $thing;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testMap{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftTest::ThriftTest_testMap_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testMap failed: unknown result";
}
sub testStringMap{
  my $self = shift;
  my $thing = shift;

    $self->send_testStringMap($thing);
  return $self->recv_testStringMap();
}

sub send_testStringMap{
  my $self = shift;
  my $thing = shift;

  $self->{output}->writeMessageBegin('testStringMap', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftTest::ThriftTest_testStringMap_args();
  $args->{thing} = $thing;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testStringMap{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftTest::ThriftTest_testStringMap_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testStringMap failed: unknown result";
}
sub testSet{
  my $self = shift;
  my $thing = shift;

    $self->send_testSet($thing);
  return $self->recv_testSet();
}

sub send_testSet{
  my $self = shift;
  my $thing = shift;

  $self->{output}->writeMessageBegin('testSet', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftTest::ThriftTest_testSet_args();
  $args->{thing} = $thing;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testSet{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftTest::ThriftTest_testSet_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testSet failed: unknown result";
}
sub testList{
  my $self = shift;
  my $thing = shift;

    $self->send_testList($thing);
  return $self->recv_testList();
}

sub send_testList{
  my $self = shift;
  my $thing = shift;

  $self->{output}->writeMessageBegin('testList', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftTest::ThriftTest_testList_args();
  $args->{thing} = $thing;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testList{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftTest::ThriftTest_testList_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testList failed: unknown result";
}
sub testEnum{
  my $self = shift;
  my $thing = shift;

    $self->send_testEnum($thing);
  return $self->recv_testEnum();
}

sub send_testEnum{
  my $self = shift;
  my $thing = shift;

  $self->{output}->writeMessageBegin('testEnum', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftTest::ThriftTest_testEnum_args();
  $args->{thing} = $thing;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testEnum{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftTest::ThriftTest_testEnum_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testEnum failed: unknown result";
}
sub testTypedef{
  my $self = shift;
  my $thing = shift;

    $self->send_testTypedef($thing);
  return $self->recv_testTypedef();
}

sub send_testTypedef{
  my $self = shift;
  my $thing = shift;

  $self->{output}->writeMessageBegin('testTypedef', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftTest::ThriftTest_testTypedef_args();
  $args->{thing} = $thing;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testTypedef{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftTest::ThriftTest_testTypedef_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testTypedef failed: unknown result";
}
sub testMapMap{
  my $self = shift;
  my $hello = shift;

    $self->send_testMapMap($hello);
  return $self->recv_testMapMap();
}

sub send_testMapMap{
  my $self = shift;
  my $hello = shift;

  $self->{output}->writeMessageBegin('testMapMap', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftTest::ThriftTest_testMapMap_args();
  $args->{hello} = $hello;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testMapMap{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftTest::ThriftTest_testMapMap_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testMapMap failed: unknown result";
}
sub testInsanity{
  my $self = shift;
  my $argument = shift;

    $self->send_testInsanity($argument);
  return $self->recv_testInsanity();
}

sub send_testInsanity{
  my $self = shift;
  my $argument = shift;

  $self->{output}->writeMessageBegin('testInsanity', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftTest::ThriftTest_testInsanity_args();
  $args->{argument} = $argument;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testInsanity{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftTest::ThriftTest_testInsanity_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testInsanity failed: unknown result";
}
sub testMulti{
  my $self = shift;
  my $arg0 = shift;
  my $arg1 = shift;
  my $arg2 = shift;
  my $arg3 = shift;
  my $arg4 = shift;
  my $arg5 = shift;

    $self->send_testMulti($arg0, $arg1, $arg2, $arg3, $arg4, $arg5);
  return $self->recv_testMulti();
}

sub send_testMulti{
  my $self = shift;
  my $arg0 = shift;
  my $arg1 = shift;
  my $arg2 = shift;
  my $arg3 = shift;
  my $arg4 = shift;
  my $arg5 = shift;

  $self->{output}->writeMessageBegin('testMulti', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftTest::ThriftTest_testMulti_args();
  $args->{arg0} = $arg0;
  $args->{arg1} = $arg1;
  $args->{arg2} = $arg2;
  $args->{arg3} = $arg3;
  $args->{arg4} = $arg4;
  $args->{arg5} = $arg5;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testMulti{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftTest::ThriftTest_testMulti_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testMulti failed: unknown result";
}
sub testException{
  my $self = shift;
  my $arg = shift;

    $self->send_testException($arg);
  $self->recv_testException();
}

sub send_testException{
  my $self = shift;
  my $arg = shift;

  $self->{output}->writeMessageBegin('testException', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftTest::ThriftTest_testException_args();
  $args->{arg} = $arg;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testException{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftTest::ThriftTest_testException_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{err1}) {
    die $result->{err1};
  }
  return;
}
sub testMultiException{
  my $self = shift;
  my $arg0 = shift;
  my $arg1 = shift;

    $self->send_testMultiException($arg0, $arg1);
  return $self->recv_testMultiException();
}

sub send_testMultiException{
  my $self = shift;
  my $arg0 = shift;
  my $arg1 = shift;

  $self->{output}->writeMessageBegin('testMultiException', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftTest::ThriftTest_testMultiException_args();
  $args->{arg0} = $arg0;
  $args->{arg1} = $arg1;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testMultiException{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftTest::ThriftTest_testMultiException_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{err1}) {
    die $result->{err1};
  }
  if (defined $result->{err2}) {
    die $result->{err2};
  }
  die "testMultiException failed: unknown result";
}
sub testOneway{
  my $self = shift;
  my $secondsToSleep = shift;

    $self->send_testOneway($secondsToSleep);
}

sub send_testOneway{
  my $self = shift;
  my $secondsToSleep = shift;

  $self->{output}->writeMessageBegin('testOneway', TMessageType::ONEWAY, $self->{seqid});
  my $args = new ThriftTest::ThriftTest_testOneway_args();
  $args->{secondsToSleep} = $secondsToSleep;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}
package ThriftTest::ThriftTestProcessor;

use strict;


sub new {
    my ($classname, $handler) = @_;
    my $self      = {};
    $self->{handler} = $handler;
    return bless ($self, $classname);
}

sub process {
    my ($self, $input, $output) = @_;
    my $rseqid = 0;
    my $fname  = undef;
    my $mtype  = 0;

    $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
    my $methodname = 'process_'.$fname;
    if (!$self->can($methodname)) {
      $input->skip(TType::STRUCT);
      $input->readMessageEnd();
      my $x = new TApplicationException('Function '.$fname.' not implemented.', TApplicationException::UNKNOWN_METHOD);
      $output->writeMessageBegin($fname, TMessageType::EXCEPTION, $rseqid);
      $x->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      return;
    }
    $self->$methodname($rseqid, $input, $output);
    return 1;
}

sub process_testVoid {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftTest::ThriftTest_testVoid_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftTest::ThriftTest_testVoid_result();
    $self->{handler}->testVoid();
    $output->writeMessageBegin('testVoid', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testString {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftTest::ThriftTest_testString_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftTest::ThriftTest_testString_result();
    $result->{success} = $self->{handler}->testString($args->thing);
    $output->writeMessageBegin('testString', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testByte {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftTest::ThriftTest_testByte_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftTest::ThriftTest_testByte_result();
    $result->{success} = $self->{handler}->testByte($args->thing);
    $output->writeMessageBegin('testByte', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testI32 {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftTest::ThriftTest_testI32_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftTest::ThriftTest_testI32_result();
    $result->{success} = $self->{handler}->testI32($args->thing);
    $output->writeMessageBegin('testI32', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testI64 {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftTest::ThriftTest_testI64_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftTest::ThriftTest_testI64_result();
    $result->{success} = $self->{handler}->testI64($args->thing);
    $output->writeMessageBegin('testI64', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testDouble {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftTest::ThriftTest_testDouble_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftTest::ThriftTest_testDouble_result();
    $result->{success} = $self->{handler}->testDouble($args->thing);
    $output->writeMessageBegin('testDouble', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testStruct {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftTest::ThriftTest_testStruct_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftTest::ThriftTest_testStruct_result();
    $result->{success} = $self->{handler}->testStruct($args->thing);
    $output->writeMessageBegin('testStruct', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testNest {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftTest::ThriftTest_testNest_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftTest::ThriftTest_testNest_result();
    $result->{success} = $self->{handler}->testNest($args->thing);
    $output->writeMessageBegin('testNest', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testMap {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftTest::ThriftTest_testMap_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftTest::ThriftTest_testMap_result();
    $result->{success} = $self->{handler}->testMap($args->thing);
    $output->writeMessageBegin('testMap', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testStringMap {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftTest::ThriftTest_testStringMap_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftTest::ThriftTest_testStringMap_result();
    $result->{success} = $self->{handler}->testStringMap($args->thing);
    $output->writeMessageBegin('testStringMap', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testSet {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftTest::ThriftTest_testSet_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftTest::ThriftTest_testSet_result();
    $result->{success} = $self->{handler}->testSet($args->thing);
    $output->writeMessageBegin('testSet', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testList {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftTest::ThriftTest_testList_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftTest::ThriftTest_testList_result();
    $result->{success} = $self->{handler}->testList($args->thing);
    $output->writeMessageBegin('testList', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testEnum {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftTest::ThriftTest_testEnum_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftTest::ThriftTest_testEnum_result();
    $result->{success} = $self->{handler}->testEnum($args->thing);
    $output->writeMessageBegin('testEnum', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testTypedef {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftTest::ThriftTest_testTypedef_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftTest::ThriftTest_testTypedef_result();
    $result->{success} = $self->{handler}->testTypedef($args->thing);
    $output->writeMessageBegin('testTypedef', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testMapMap {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftTest::ThriftTest_testMapMap_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftTest::ThriftTest_testMapMap_result();
    $result->{success} = $self->{handler}->testMapMap($args->hello);
    $output->writeMessageBegin('testMapMap', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testInsanity {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftTest::ThriftTest_testInsanity_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftTest::ThriftTest_testInsanity_result();
    $result->{success} = $self->{handler}->testInsanity($args->argument);
    $output->writeMessageBegin('testInsanity', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testMulti {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftTest::ThriftTest_testMulti_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftTest::ThriftTest_testMulti_result();
    $result->{success} = $self->{handler}->testMulti($args->arg0, $args->arg1, $args->arg2, $args->arg3, $args->arg4, $args->arg5);
    $output->writeMessageBegin('testMulti', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testException {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftTest::ThriftTest_testException_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftTest::ThriftTest_testException_result();
    eval {
      $self->{handler}->testException($args->arg);
    }; if( UNIVERSAL::isa($@,'ThriftTest::Xception') ){ 
      $result->{err1} = $@;
    }
    $output->writeMessageBegin('testException', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testMultiException {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftTest::ThriftTest_testMultiException_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftTest::ThriftTest_testMultiException_result();
    eval {
      $result->{success} = $self->{handler}->testMultiException($args->arg0, $args->arg1);
    }; if( UNIVERSAL::isa($@,'ThriftTest::Xception') ){ 
      $result->{err1} = $@;
        }; if( UNIVERSAL::isa($@,'ThriftTest::Xception2') ){ 
      $result->{err2} = $@;
    }
    $output->writeMessageBegin('testMultiException', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testOneway {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftTest::ThriftTest_testOneway_args();
    $args->read($input);
    $input->readMessageEnd();
    $self->{handler}->testOneway($args->secondsToSleep);
    return;
}
1;
